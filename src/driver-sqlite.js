'use strict';

const sqlite3 = require('sqlite3');
const Result = require('./result');
const util = require('./sql-util');

// Escape quotes for SQLite-compatible strings
const sanitize = (str) => String(str).replace(/'/g, "''");

const rollbackOnError = (db, error, result, callback) => {
  return util.handleError(error, result, () =>
    db.exec('ROLLBACK', () => callback(result))
  );
};

// Run multiple non-prepared statements
const multiExec = (db, statements) => {
  const result = new Result();

  if (!(statements instanceof Array)) {
    statements = [statements];
  }

  return new Promise((resolve, reject) =>
    db.serialize(() => db.exec(statements.join('; '), error => {
      if (rollbackOnError(db, error, result, reject)) {
        return;
      }

      result.success = true;
      resolve(result);
    }))
  );
};

class Driver {
  init(dbFile) {
    this.db = new sqlite3.Database(dbFile);
    this.transactionIsOpen = false;
  }

  close() {
    return new Promise((resolve, reject) => this.db.close(err => err ? reject(err) : resolve()));
  }

  // General query that wraps rows in a Result object
  query(query, params) {
    const result = new Result();
    params = params || [];

    return new Promise((resolve, reject) =>
      this.db.serialize(() => this.db.all(query, params, (err, data) => {
        if (!util.handleError(err, result, reject)) {
          result.success = true;
          result.data = data;

          resolve(result);
        }
      }))
    );
  }

  // Execute non-query statements
  exec(statement, params) {
    const result = new Result();
    params = params || [];

    return new Promise((resolve, reject) =>
      this.db.serialize(() => this.db.run(statement, params, function(err) {
        if (!util.handleError(err, result, reject)) {
          result.success = true;
          result.data = this;

          resolve(result);
        }
      }))
    );
  }

  // Get an individual store's metadata
  getMetaData(store) {
    const sql = 'SELECT data FROM __meta WHERE `store` = ?';

    return this.query(sql, [store]).then(result => {
      let meta;

      if (!result.data || !result.data.length) {
        result.setError('No meta rows returned');
        return Promise.reject(result);
      }

      try {
        meta = JSON.parse(result.data[0].data);
      } catch (err) {
        result.setError(`Could not parse meta JSON: ${err}`);
        return Promise.reject(result);
      }

      result.success = true;
      result.data = meta;
      return result;
    });
  }

  createStore(name, keys) {
    return multiExec(this.db, util.createStore(name, keys, sanitize));
  }

  deleteStore(name) {
    const statements = [
      'BEGIN',
      `DELETE FROM __meta WHERE \`store\` = '${sanitize(name)}'`,
      `DROP TABLE ${sanitize(name)}`,
      'COMMIT'
    ];

    return multiExec(this.db, statements);
  }

  save(store, object, keys) {
    return Promise.resolve().then(() => {
      if (this.transactionIsOpen) {
        // A manually-opened transaction is already in progress
        return;
      }

      // Begin transaction
      return this.exec('BEGIN');
    }).then(() => {
      // Get key schema from metadata
      return this.getMetaData(store);
    }).then(result => {
      // Insert data
      const meta = result.data;
      const keyData = {};

      // Skim the object for top-level keys
      Object.keys(object).forEach(key => {
        if (meta.keys.indexOf(key) !== -1) {
          keyData[`:${key}`] = object[key];
        }
      });

      // Allow keys param to override assumed key values
      Object.keys(keys).forEach(key => {
        if (meta.keys.indexOf(key) !== -1) {
          keyData[`:${key}`] = keys[key];
        }
      });

      // Make sure an overidden ID key makes it into the object
      if (typeof keys.id !== 'undefined') {
        object.id = keys.id;
      }

      // Get keynames without bind prefix
      const keyNames = Object.keys(keyData).map(key => key.slice(1));

      // Add the serialized JSON object to the row
      keyNames.push('__jsondata');
      keyData[':__jsondata'] = JSON.stringify(object);

      // Build insert query
      const sql = `
        INSERT OR REPLACE INTO \`${store}\` (
          ${keyNames.map(key => `\`${key}\``).join(', ')}
        ) VALUES (
          ${keyNames.map(key => `:${key}`).join(', ')}
        );`;

      // Execute insert statement
      return this.exec(sql, keyData).then(result => {
        if (this.transactionIsOpen) {
          // A manually-opened transaction must also be closed manually
          return result;
        }

        // End transaction
        return this.exec('COMMIT').then(() => result);
      }).then(result => {
        // If object does not have an ID key, we take
        // the ID generated by SQLite, modify the object to include it,
        // and re-save the modified object.
        if (typeof keyData[':id'] === 'undefined') {
          if (typeof result.data.lastID !== 'undefined') {
            object.id = result.data.lastID;
            return this.save(store, object, keys);
          }

          result.setError('No ID key found in object or from SQLite');
          return Promise.reject(result);
        }

        result.data = object;
        return result;
      });
    });
  }

  getQuery(store, criteria, params) {
    return `SELECT __jsondata FROM ${store}` + util.expandCriteria(criteria, sanitize, params);
  }

  get(store, criteria) {
    const params = [];
    return this.query(this.getQuery(store, criteria, params), params).then(result => {
      if (!result.data) {
        result.setError('No JSON data returned');
        return Promise.reject(result);
      }

      try {
        result.data = JSON.parse(`[${result.data.map(r => r.__jsondata).join(',')}]`);
      } catch (err) {
        result.setError(err);
        return Promise.reject(result);
      }

      return result;
    });
  }

  stream(store, criteria, callback) {
    const result = new Result();
    let currentRow = null;

    this.db.serialize(() => this.db.each(
      this.getQuery(store, criteria),

      // Callback for every row except the last one
      (err, row) => {
        if (err) {
          result.setError(err);
          return callback(result);
        }

        if (!row.__jsondata) {
          result.setError('No JSON data returned');
          return callback(result);
        }

        if (currentRow) {
          result.success = true;
          result.data = currentRow;
          callback(result);
        }

        try {
          currentRow = JSON.parse(row.__jsondata);
        } catch (err) {
          result.setError(err);
          return callback(result);
        }
      },

      // Callback for the last row only
      (err, numRows) => {
        if (err) {
          result.setError(err);
          return callback(result, true);
        }

        result.success = true;
        result.data = currentRow;
        callback(result, true, numRows);
      }
    ));
  }

  delete(store, criteria) {
    const params = [];
    const sql = `DELETE FROM ${store}` + util.expandCriteria(criteria, sanitize, params);

    return this.exec(sql, params);
  }

  transactionBegin() {
    this.transactionIsOpen = true;
    return this.exec('BEGIN').then(() => { this.transactionIsOpen = true; });
  }

  transactionEnd(method) {
    return this.exec(method)
      .then(() => { this.transactionIsOpen = false; })
      .catch(err => {
        this.transactionIsOpen = false;
        return Promise.reject(err);
      });
  }

  transactionCommit() {
    return this.transactionEnd('COMMIT');
  }

  transactionRollback() {
    return this.transactionEnd('ROLLBACK');
  }
}

module.exports = Driver;
