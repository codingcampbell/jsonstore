'use strict';

const async = require('async');
const sqlite3 = require('sqlite3');
const Result = require('./result');
const util = require('./sql-util');
const noop = function() {};

// Escape quotes for SQLite-compatible strings
const sanitize = (str) => String(str).replace(/'/g, "''");

// Run multiple non-prepared statements
const multiExec = (db, statements, callback) => {
  let result = new Result();

  if (!(statements instanceof Array)) {
    statements = [statements];
  }

  callback = callback || noop;

  db.serialize(() => db.exec(statements.join('; '), error => {
    if (util.handleError(error, result, callback)) {
      return noop;
    }

    result.success = true;
    callback(result);
  }));
};

class Driver {
  init(dbFile) {
    this.db = new sqlite3.Database(dbFile);
  }

  // General query that wraps rows in a Result object
  query(query, params, callback) {
    let result = new Result()

    if (typeof params === 'function') {
      callback = params;
      params = [];
    }

    this.db.serialize(() => this.db.all(query, params, (err, data) => {
      if (!util.handleError(err, result, callback)) {
        result.success = true;
        result.data = data;

        callback(result);
      }
    }));
  }

  // Execute non-query statements
  exec(statement, params, callback) {
    let result = new Result();

    if (typeof params === 'function') {
      callback = params;
      params = [];
    }

    this.db.serialize(() => this.db.run(statement, params, function (err, data) {
      if (!util.handleError(err, result, callback)) {
        result.success = true;
        result.data = this;

        callback(result);
      }
    }));
  }

  // Get an individual store's metadata
  getMetaData(store, callback) {
    let sql = 'SELECT data FROM __meta WHERE `store` = ?';

    this.query(sql, [store], result => {
      let meta;

      if (!result.success) {
        return callback(result);
      }

      if (!result.data || !result.data.length) {
        result.setError('No meta rows returned');
        return callback(result);
      }

      try {
        meta = JSON.parse(result.data[0].data);
      } catch (err) {
        result.setError(`Could not parse meta JSON: ${err}`);
        return callback(result);
      }

      result.success = true;
      result.data = meta;
      return callback(result);
    });
  }

  createStore(name, keys, callback) {
    let statements = util.createStore(name, keys, sanitize);
    multiExec(this.db, statements, callback);
  }

  deleteStore(name, callback) {
    let statements = [
      'BEGIN',
      `DELETE FROM __meta WHERE \`store\` = '${sanitize(name)}'`,
      `DROP TABLE ${sanitize(name)}`,
      'COMMIT'
    ];

    multiExec(this.db, statements, callback);
  }

  save(store, object, keys, callback) {
    return async.waterfall([
      // Begin transaction
      callback => this.exec('BEGIN', () => callback(null)),

      // Get key schema from metadata
      callback => this.getMetaData(store, result => {
        if (!result.success) {
          return callback(result);
        }

        callback(null, result.data);
      }),

      // Insert data
      (meta, callback) => {
        let keyData = {};

        // Skim the object for top-level keys
        Object.keys(object).forEach(key => {
          if (meta.keys.indexOf(key) !== -1) {
            keyData[`:${key}`] = object[key];
          }
        });

        // Allow keys param to override assumed key values
        Object.keys(keys).forEach(key => {
          if (meta.keys.indexOf(key) !== -1) {
            keyData[`:${key}`] = keys[key];
          }
        });

        // Make sure an overidden ID key makes it into the object
        if (typeof keys.id !== 'undefined') {
          object.id = keys.id;
        }

        // Get keynames without bind prefix
        let keyNames = Object.keys(keyData).map(key => key.slice(1));

        // Add the serialized JSON object to the row
        keyNames.push('__jsondata');
        keyData[':__jsondata'] = JSON.stringify(object);

        // Build insert query
        let sql = `
          INSERT OR REPLACE INTO \`${store}\` (
            ${keyNames.map(key => `\`${key}\``).join(', ')}
          ) VALUES (
            ${keyNames.map(key => `:${key}`).join(', ')}
          );`;

        // Execute insert statement
        this.exec(sql, keyData, result => {
          if (!result.success) {
            return callback(result);
          }

          // If object does not have an ID key, we take
          // the ID generated by SQLite, modify the object to include it,
          // and re-save the modified object.
          if (typeof keyData[':id'] === 'undefined') {
            if (typeof result.data.lastID !== 'undefined') {
              object.id = result.data.lastID;
              return this.save(store, object, keys, result => callback(null, result));
            }

            result.setError('No ID key found in object or from SQLite');
            return callback(result);
          }

          result.data = object
          callback(null, result)
        });
      },

      // Process result and notify callbacks of errors
      (result, callback) => {
        if (!result.success) {
          return callback(result);
        }

        callback(null, result);
      },

      // End transaction
      (result, callback) => this.exec('COMMIT', () => callback(null, result))
    ], (err, result) => callback(err || result));
  }

  getQuery(store, criteria, params) {
    return `SELECT __jsondata FROM ${store}` + util.expandCriteria(criteria, sanitize, params);
  }

  get(store, criteria, callback) {
    let params = [];
    this.query(this.getQuery(store, criteria, params), params, result => {
      if (!result.success) {
        return callback(result);
      }

      if (!result.data) {
        result.setError('No JSON data returned');
        return callback(result);
      }

      try {
        result.data = JSON.parse(`[${result.data.map(r => r['__jsondata']).join(',')}]`);
      } catch (err) {
        result.setError(err);
        return callback(result);
      }

      callback(result);
    })
  }

  stream(store, criteria, callback) {
    let result = new Result();
    let currentRow = null;

    this.db.serialize(() => this.db.each(
      this.getQuery(store, criteria),

      // Callback for every row except the last one
      (err, row) => {
        if (err) {
          result.setError(err);
          return callback(result);
        }

        if (!row['__jsondata']) {
          result.setError('No JSON data returned');
          return callback(result);
        }

        if (currentRow) {
          result.success = true;
          result.data = currentRow;
          callback(result);
        }

        try {
          currentRow = JSON.parse(row['__jsondata'])
        } catch (err) {
          result.setError(err);
          return callback(result);
        }
      },

      // Callback for the last row only
      (err, numRows) => {
        if (err) {
          result.setError(err);
          return callback(result, true);
        }

        result.success = true;
        result.data = currentRow;
        callback(result, true, numRows);
      }
    ));
  }

  delete(store, criteria, callback) {
    let params = [];
    let sql = `DELETE FROM ${store}` + util.expandCriteria(criteria, sanitize, params);

    this.exec(sql, params, callback);
  }
};

module.exports = Driver;
